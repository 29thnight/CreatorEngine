#include "EntityEnemy.h"
#include "pch.h"
#include "Player.h"
#include "EffectComponent.h"
#include "BehaviorTreeComponent.h"
#include "Blackboard.h"
#include "RaycastHelper.h"
void EntityEnemy::Start()
{
	enemyBT =GetOwner()->GetComponent<BehaviorTreeComponent>();
	blackBoard = enemyBT->GetBlackBoard();

}

void EntityEnemy::Update(float tick)
{
	/*Mathf::Vector3 forward = GetOwner()->m_transform.GetForward();
	std::cout << "Enemy Forward: " << forward.x << " " << forward.y << " " << forward.z << std::endl;*/

	if (criticalMark != CriticalMark::None)
	{
		if (criticalMark == CriticalMark::P1)
		{
			auto obj = GameObject::Find("red");
			Mathf::Vector3 pos = GetOwner()->m_transform.GetWorldPosition();
			pos.y += 5;
			obj->m_transform.SetPosition(pos);
			obj->m_transform.UpdateWorldMatrix();
			auto effect = obj->GetComponent<EffectComponent>();
			if (effect)
			{
				effect->PlayEffectByName("red");
			}
		}
		else if (criticalMark == CriticalMark::P2)
		{

		}
	}

	attackCount = blackBoard->GetValueAsInt("AttackCount");

	//if (attackCount > 0) {
		MeleeAttack();
	//}


	if (isDead)
	{
		//effect
		Destroy();
	}
}

void EntityEnemy::SetCriticalMark(int playerIndex)
{
	if (playerIndex == 0)
	{
		criticalMark = CriticalMark::P1;
	}
	else if (playerIndex == 1)
	{
		criticalMark = CriticalMark::P2;
	}
}

void EntityEnemy::Attack(Entity* sender, int damage)
{

	if (sender)
	{
		auto player = dynamic_cast<Player*>(sender);
		//CurrHP - damae;
		if (player)
		{
			blackBoard->SetValueAsInt("Damage", damage);
			int playerIndex = player->playerIndex;
			m_currentHP -= std::max(damage, 0);
			if (m_currentHP >= 0)
			{
				isDead = true;
			}
		}
	}
}

void EntityEnemy::MeleeAttack()
{
	if (isDead) return;
	Mathf::Vector3 pos = GetOwner()->m_transform.GetWorldPosition();
	bool hasDir = blackBoard->HasKey("AttackDirection");
	Mathf::Vector3 dir;
	if (!hasDir) {
		return; // 공격 방향이 없으면 리턴
	}
	dir = blackBoard->GetValueAsVector3("AttackDirection");

	//dir.z = -dir.z; // z축 반전, z축이 앞으로 가도록
	dir.y = 0.f; // y축은 무시하고 수평 방향으로만 공격
	//transform forward base 나중에 쓰자
	//Mathf::Vector3 forward = GetOwner()->m_transform.GetForward();
	//pos += forward * 2.f;
	//케릭터 높이 고려 기본 높이 0.5로 판단

	//궤적에 따른 레이방향 2개 추가
	Mathf::Vector3 dir1 = dir;
	Mathf::Vector3 dir2 = dir;
	
	//지금 바라보는 방향에서 좌우가 x인가 z인가 판별
	if (std::abs(dir.x) > std::abs(dir.z)) // x축이 더 크면 좌우
	{
		dir1.x += 0.5f; // 오른쪽으로 약간 이동
		dir2.x -= 0.5f; // 왼쪽으로 약간 이동
	}
	else // z축이 더 크면 앞뒤
	{
		dir1.z += 0.5f; // 앞으로 약간 이동
		dir2.z -= 0.5f; // 뒤로 약간 이동
	}

	pos.y = 0.5f; // ray cast height 
	//forward.y = 0.5f; // ray cast height

	//debug용
	//Mathf::Vector3 endpos = pos + forward * 10.f;
	//std::cout << "Start Pos: " << pos.x << " " << pos.y << " " << pos.z << std::endl;
	//forward.Normalize();
	//std::cout << forward.x << " " << forward.y << " " << forward.z << std::endl;
	
	//std::cout << "End Pos: " << endpos.x << " " << endpos.y << " " << endpos.z << std::endl;


	

	std::vector<HitResult> hits;
	int size = RaycastAll(pos, dir, 2.f, ~0, hits);

	std::vector<HitResult> hits1;
	int size1 = RaycastAll(pos, dir1, 1.7f, ~0, hits1);
	std::vector<HitResult> hits2;
	int size2 = RaycastAll(pos, dir2, 1.7f, ~0, hits2);

	hits.insert(hits.end(), hits1.begin(), hits1.end());
	hits.insert(hits.end(), hits2.begin(), hits2.end());


	//std::cout << dir.x << " " << dir.y << " " << dir.z << std::endl;
	std::cout << "Hit Count: " << size << std::endl;
	
	for (auto& hit : hits)
	{
		auto object = hit.hitObject;
		if (object == GetOwner()) continue;
		std::cout << object->m_name.data() << std::endl;

		//todo : 알아서 바꾸셈 player 인지 확인 하고 데미지를 주든 알아서하셈
		//object->Destroy();
	}
	
	attackCount -= 1;
	blackBoard->SetValueAsInt("AttackCount", attackCount);
}


